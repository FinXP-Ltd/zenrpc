{{define "Returns" -}}
    {{- if .Returns | len | eq 2 -}}
    return {{ if .Returns.HasStar }}&{{ end }}res, nil
    {{- else }}
    return {{ if .Returns.HasStar }}&{{ end }}res
    {{- end -}}
{{end}}
// Code generated by zenrpc; DO NOT EDIT.
package jrpc2

import (		
    "os"
    "io"
    "net/http"
	"net/url"
    "log/slog"
    "time"

    "{{.PackagePath}}"
    "go.lsp.dev/jsonrpc2"

	{{ range .ImportsIncludedToGeneratedCode}}
		{{if .Name}}{{.Name.Name}} {{end}}{{.Path.Value}}
	{{- end }}
)

const (
    userAgent      = "jsonprc-{{.PackageName}}-client"
    accept         = "application/json"
    acceptEncoding = "gzip, deflate, br"
)

var (
    defaultLoger = slog.New(slog.NewJSONHandler(os.Stderr, &slog.HandlerOptions{
        Level: slog.LevelInfo,
    }))
)

type sw struct {
    io.ReadWriter
}
func (s sw) Close() error { return nil }

{{- range $s := .Services}}
type {{$s.Name}}ClientOpt func(*{{$s.Name}}Client)

type {{$s.Name}}Client struct {
    Client *http.Client 
    Logger *slog.Logger
    BaseURL   *url.URL
    UserAgent string
    Token string
    Conn jsonrpc2.Conn
}


func New{{$s.Name}}Client(baseURL *url.URL, token string , opts... {{$s.Name}}ClientOpt) *{{$s.Name}}Client {
    c :=  &{{$s.Name}}Client{      
        Client: http.DefaultClient,
        BaseURL: baseURL,
        UserAgent: userAgent,
        Token: token,
        Logger: defaultLoger,     
    }

    for _, opt := range opts {
        opt(c)
    }

    if c.Conn == nil {
        w :=  sw{}
        stream := jsonrpc2.NewStream(w)
       c.Conn = jsonrpc2.NewConn(stream)
    }

    return c 
}

{{- range $m := $s.Methods}}
{{  $s.Description }}
func (c *{{$s.Name}}Client) {{ $m.Source }} {
    {{- if $m.Args | len | lt 2 }}
    var params = struct {
        {{- range .Args}}
        {{ if ne .JsonName  "ctx" -}}{{.CapitalName}} {{.STypeWithoutEllipsis}} `json:"{{.JsonName}}"`{{ end -}} 
        {{- end -}}
    }{
        {{- range .Args}}
        {{- if ne .JsonName  "ctx" -}}{{.CapitalName}}: {{.JsonName}},{{ end }}
        {{ end }}
    }
    
    {{- if $m.Returns | len | eq 2 }}
        var res {{ $m.ReturnSource }}
    {{- else  }}
        var res any
    {{- end }}
    _, err := c.call(ctx, "{{ $m.JSONName }}", params, &res)    

    {{- else}}

    {{- if $m.Returns | len | eq 2 }}
        var res {{ $m.ReturnSource }}
    {{- else  }}
        var res error
    {{- end }}
    _, err := c.call(ctx, "{{ $m.JSONName }}", {{ range $i, $a := $m.Args -}}{{ if ne $i 0 }}{{$a.JsonName}}{{- end }}{{- end }}, &res)    
    {{- end }}    
    if err != nil {
        return {{ if $m.Returns | len | eq 2 }}{{ if .Returns.HasStar }}&{{ end }}res, {{ end }}err
    }
    {{template "Returns" $m }}
}

{{- end}}
func (c *{{$s.Name}}Client) call(ctx context.Context, method string, params, result any) ( jsonrpc2.ID ,error) {
    _start := time.Now()
    c.Logger.Debug("--> {{$s.Name}}Client Call", 
        "method", method, "params", params,
    )
    jid, err := c.Conn.Call(ctx, method, params, result)
    defer func () {
        if err != nil {
            c.Logger.Error("<-- {{$s.Name}}Client Call",  
                "jid", jid, "err", err, "dur", time.Since(_start))
            return
        }

        c.Logger.Debug("<-- {{$s.Name}}Client Call", 
            "jid", jid, "result", result, "dur", time.Since(_start))
    }()    
    return jid, err
}
{{- end}}


